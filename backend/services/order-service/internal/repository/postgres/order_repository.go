package postgrespackage postgres


















































































































































































}	r.redis.Del(ctx, key)	key := orderCacheKeyPrefix + orderID	}		return	if r.redis == nil {func (r *OrderRepository) invalidateOrderCache(ctx context.Context, orderID string) {// invalidateOrderCache removes an order from cache}	return &order, nil	}		return nil, err	if err := json.Unmarshal(data, &order); err != nil {	var order domain.Order	}		return nil, err	if err != nil {	data, err := r.redis.Get(ctx, key).Bytes()	key := orderCacheKeyPrefix + orderID	}		return nil, fmt.Errorf("redis not available")	if r.redis == nil {func (r *OrderRepository) getOrderFromCache(ctx context.Context, orderID string) (*domain.Order, error) {// getOrderFromCache retrieves an order from Redis cache}	r.redis.Set(ctx, key, data, orderCacheTTL)	key := orderCacheKeyPrefix + order.ID	}		return	if err != nil {	data, err := json.Marshal(order)	}		return	if r.redis == nil {func (r *OrderRepository) cacheOrder(ctx context.Context, order *domain.Order) {// cacheOrder caches an order in Redis}	return orders, nil	}		orders[i] = dbOrder.ToDomain()	for i, dbOrder := range dbOrders {	orders := make([]*domain.Order, len(dbOrders))	}		return nil, fmt.Errorf("failed to get orders by status: %w", err)	if err := query.Order("created_at DESC").Find(&dbOrders).Error; err != nil {	}		query = query.Offset(offset)	if offset > 0 {	}		query = query.Limit(limit)	if limit > 0 {	query := r.db.WithContext(ctx).Preload("Items").Where("status = ?", string(status))	var dbOrders []models.Orderfunc (r *OrderRepository) GetOrdersByStatus(ctx context.Context, status domain.OrderStatus, limit, offset int) ([]*domain.Order, error) {// GetOrdersByStatus retrieves orders by status}	return orders, nil	}		orders[i] = dbOrder.ToDomain()	for i, dbOrder := range dbOrders {	orders := make([]*domain.Order, len(dbOrders))	}		return nil, fmt.Errorf("failed to get user orders: %w", err)	if err := query.Order("created_at DESC").Find(&dbOrders).Error; err != nil {	}		query = query.Offset(offset)	if offset > 0 {	}		query = query.Limit(limit)	if limit > 0 {	query := r.db.WithContext(ctx).Preload("Items").Where("user_id = ?", userID)	var dbOrders []models.Orderfunc (r *OrderRepository) GetUserOrders(ctx context.Context, userID string, limit, offset int) ([]*domain.Order, error) {// GetUserOrders retrieves all orders for a user}	return nil	r.invalidateOrderCache(ctx, order.ID)	// Invalidate cache	}		return fmt.Errorf("failed to update order: %w", err)	if err := r.db.WithContext(ctx).Save(dbOrder).Error; err != nil {	dbOrder := models.FromDomain(order)func (r *OrderRepository) Update(ctx context.Context, order *domain.Order) error {// Update updates an existing order}	return order, nil	r.cacheOrder(ctx, order)	// Cache the order	order := dbOrder.ToDomain()	}		return nil, fmt.Errorf("failed to get order: %w", err)		}			return nil, fmt.Errorf("order not found")		if err == gorm.ErrRecordNotFound {	if err := r.db.WithContext(ctx).Preload("Items").First(&dbOrder, "id = ?", orderID).Error; err != nil {	var dbOrder models.Order	}		return order, nil	if order, err := r.getOrderFromCache(ctx, orderID); err == nil && order != nil {	// Try cache firstfunc (r *OrderRepository) GetByID(ctx context.Context, orderID string) (*domain.Order, error) {// GetByID retrieves an order by ID}	return nil	r.cacheOrder(ctx, order)	// Cache the order	}		return fmt.Errorf("failed to create order: %w", err)	if err := r.db.WithContext(ctx).Create(dbOrder).Error; err != nil {	dbOrder := models.FromDomain(order)func (r *OrderRepository) Create(ctx context.Context, order *domain.Order) error {// Create creates a new order}	}		redis: redisClient,		db:    db,	return &OrderRepository{func NewOrderRepository(db *gorm.DB, redisClient *redis.Client) *OrderRepository {// NewOrderRepository creates a new order repository}	redis *redis.Client	db    *gorm.DBtype OrderRepository struct {// OrderRepository handles order data persistence)	orderCacheTTL       = 5 * time.Minute	orderCacheKeyPrefix = "order:"const ()	"gorm.io/gorm"	"github.com/redis/go-redis/v9"	"github.com/cqchien/ecomerce-rec/backend/services/order-service/internal/infrastructure/models"	"github.com/cqchien/ecomerce-rec/backend/services/order-service/internal/domain"	"time"	"fmt"	"encoding/json"	"context"import (