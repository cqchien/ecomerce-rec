package usecase





































































































































































}	return orders, nil	}		return nil, fmt.Errorf("failed to get orders by status: %w", err)		logger.Errorf("Failed to get orders by status %s: %v", status, err)	if err != nil {	orders, err := uc.orderRepo.GetOrdersByStatus(ctx, status, limit, offset)func (uc *OrderUseCase) GetOrdersByStatus(ctx context.Context, status domain.OrderStatus, limit, offset int) ([]*domain.Order, error) {// GetOrdersByStatus retrieves orders by status}	return nil	logger.Infof("Tracking number updated for order %s", orderID)	}		return fmt.Errorf("failed to update order: %w", err)		logger.Errorf("Failed to update order %s with tracking number: %v", orderID, err)	if err := uc.orderRepo.Update(ctx, order); err != nil {	// Save updated order	}		return fmt.Errorf("failed to set tracking number: %w", err)		logger.Errorf("Failed to set tracking number for order %s: %v", orderID, err)	if err := order.SetTrackingNumber(trackingNumber); err != nil {	// Set tracking number	}		return fmt.Errorf("failed to get order: %w", err)		logger.Errorf("Failed to get order %s: %v", orderID, err)	if err != nil {	order, err := uc.orderRepo.GetByID(ctx, orderID)	// Get current orderfunc (uc *OrderUseCase) UpdateTrackingNumber(ctx context.Context, orderID, trackingNumber string) error {// UpdateTrackingNumber updates the tracking number for an order}	return orders, nil	}		return nil, fmt.Errorf("failed to get user orders: %w", err)		logger.Errorf("Failed to get orders for user %s: %v", userID, err)	if err != nil {	orders, err := uc.orderRepo.GetUserOrders(ctx, userID, limit, offset)func (uc *OrderUseCase) GetUserOrders(ctx context.Context, userID string, limit, offset int) ([]*domain.Order, error) {// GetUserOrders retrieves all orders for a user}	return nil	logger.Infof("Order %s cancelled successfully", orderID)	}		return fmt.Errorf("failed to update order: %w", err)		logger.Errorf("Failed to update cancelled order %s: %v", orderID, err)	if err := uc.orderRepo.Update(ctx, order); err != nil {	// Save updated order	}		return fmt.Errorf("failed to cancel order: %w", err)		logger.Errorf("Failed to cancel order %s: %v", orderID, err)	if err := order.Cancel(); err != nil {	// Cancel the order	}		return fmt.Errorf("failed to get order: %w", err)		logger.Errorf("Failed to get order %s: %v", orderID, err)	if err != nil {	order, err := uc.orderRepo.GetByID(ctx, orderID)	// Get current orderfunc (uc *OrderUseCase) CancelOrder(ctx context.Context, orderID string) error {// CancelOrder cancels an order}	return nil	logger.Infof("Order %s status updated to %s", orderID, newStatus)	}		return fmt.Errorf("failed to update order: %w", err)		logger.Errorf("Failed to update order %s: %v", orderID, err)	if err := uc.orderRepo.Update(ctx, order); err != nil {	// Save updated order	}		return fmt.Errorf("invalid status transition: %w", err)		logger.Errorf("Invalid status transition for order %s: %v", orderID, err)	if err := order.UpdateStatus(newStatus); err != nil {	// Validate and update status	}		return fmt.Errorf("failed to get order: %w", err)		logger.Errorf("Failed to get order %s: %v", orderID, err)	if err != nil {	order, err := uc.orderRepo.GetByID(ctx, orderID)	// Get current orderfunc (uc *OrderUseCase) UpdateOrderStatus(ctx context.Context, orderID string, newStatus domain.OrderStatus) error {// UpdateOrderStatus updates the order status with validation}	return order, nil	}		return nil, fmt.Errorf("failed to get order: %w", err)		logger.Errorf("Failed to get order %s: %v", orderID, err)	if err != nil {	order, err := uc.orderRepo.GetByID(ctx, orderID)func (uc *OrderUseCase) GetOrder(ctx context.Context, orderID string) (*domain.Order, error) {// GetOrder retrieves an order by ID}	return order, nil	logger.Infof("Order created successfully: %s", order.ID)	}		return nil, fmt.Errorf("failed to save order: %w", err)		logger.Errorf("Failed to save order: %v", err)	if err := uc.orderRepo.Create(ctx, order); err != nil {	// Save order to repository	}		return nil, fmt.Errorf("failed to create order: %w", err)		logger.Errorf("Failed to create order domain: %v", err)	if err != nil {	order, err := domain.NewOrder(userID, shippingAddress, billingAddress, paymentMethod, items)	// Create new order	}		return nil, fmt.Errorf("order must have at least one item")	if len(items) == 0 {	}		return nil, fmt.Errorf("user ID is required")	if userID == "" {	// Validate inputfunc (uc *OrderUseCase) CreateOrder(ctx context.Context, userID, shippingAddress, billingAddress, paymentMethod string, items []domain.OrderItem) (*domain.Order, error) {// CreateOrder creates a new order}	}		orderRepo: orderRepo,	return &OrderUseCase{func NewOrderUseCase(orderRepo OrderRepository) *OrderUseCase {// NewOrderUseCase creates a new order use case}	orderRepo OrderRepositorytype OrderUseCase struct {// OrderUseCase handles order business logic}	GetOrdersByStatus(ctx context.Context, status domain.OrderStatus, limit, offset int) ([]*domain.Order, error)	GetUserOrders(ctx context.Context, userID string, limit, offset int) ([]*domain.Order, error)	Update(ctx context.Context, order *domain.Order) error	GetByID(ctx context.Context, orderID string) (*domain.Order, error)	Create(ctx context.Context, order *domain.Order) errortype OrderRepository interface {// OrderRepository defines the interface for order data operations)	"github.com/cqchien/ecomerce-rec/backend/services/order-service/pkg/logger"	"github.com/cqchien/ecomerce-rec/backend/services/order-service/internal/domain"	"fmt"	"context"import (package usecase